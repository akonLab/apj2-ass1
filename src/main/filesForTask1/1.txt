received february 2, 2019, accepted february 18, 2019, date of publication february 25, 2019, date of current version march 12, 2019.
digital object identifier 10.1109/access.2019.2901588
efficient test case generation for
thread-safe classes
lili bo 1,2, shujuan jiang 1,2, junyan qian 3,
rongcun wang1,2, and xingya wang4
1school of computer science and technology, china university of mining and technology, xuzhou 221116, china
2engineering research center of mine digitalization, ministry of education, xuzhou 221116, china
3guangxi key laboratory of trusted software, guilin university of electronic technology, guilin 541004, china
4state key laboratory for novel software technology, nanjing university, nanjing 210093, china
corresponding author: shujuan jiang (shjjiang@cumt.edu.cn)
this work was supported in part by the national natural science foundation of china under grant 61673384 and grant 61562015, in part
by the national science foundation of jiangsu province under grant bk20181353, in part by the china postdoctoral science foundation
under grant 2015m581887, in part by the jiangsu planned projects for postdoctoral research funds under grant 2018k028c, and in part
by the innovation project for state key laboratory for novel software technology under grant zzkt2018b02.
abstract generating test cases automatically for thread-safe classes is an effective approach to validating
their correctness. however, the existing concurrent test generation techniques usually consume a large
amount of time and efforts before finding concurrency bugs. to alleviate this problem, we present an
automatic and efficient approachwhich combines the advantages of both the bug-driven and coverage-guided
techniques to generate test cases for thread-safe classes. first, method pairs that cannot be executed
concurrently are removed by the static analysis. then, a strategy of the bug-driven grouping of method
pairs is designed to divide the remaining method pairs into two groups. one group contains the method
pairs with a high priority, and another group contains the method pairs with a low priority. finally, iterative
generation of concurrent test cases, which consists of the coverage-guided generation of concurrent tests
and concurrency bug detection, is conducted to find concurrency bugs. our evaluation is on 20 thread-safe
classes. compared with four state-of-the-art approaches, the results show that our approach can obtain a
significant improvement in efficiency without impairing bug finding capacities.
index terms software testing, thread-safe class, test case generation, concurrency bug, static analysis.
i. introduction
with the shared memory mechanism and the non-
deterministic thread scheduling, concurrent software is dif-
ficult to program, to test and to debug. to alleviate this
problem, programmers usually use thread-safe classes which
encapsulatemany concurrency-related challenges. therefore,
it is critical to ensure the correctness of thread-safe classes.
automated test case generation for thread-safe classes is
an effective approach to validating their correctness [1]–[3].
previous studies have proposed many approaches to gener-
ating test cases for concurrent classes. they can be classi-
fied into three categories: random-based approaches [4]–[6],
sequential test-based approaches [7]–[9] and coverage-based
approaches [10]–[12]. random-based approaches are inef-
ficient as it may repeatedly test behaviors that have been
the associate editor coordinating the review of this manuscript and
approving it for publication was weizhi meng.
exercised and miss behaviors that can expose bugs. sequen-
tial test-based approaches depend on the pre-given test suite
of sequential tests and produce an expensive computing cost.
coverage-based approaches lie on the pre-designed coverage
requirements which guide test generation.
recently, concurrent method pairs [13], an approximate
interleaving coverage metric, is applied to concurrency bug
detection and concurrent test generation. a research shows
that 96% concurrency bugs involve no more than two
threads [14]. therefore, in the process of test generation,
two methods can constitute a method pair. then they are
scheduled by two threads in different orders. taking concur-
rent method pairs as coverage requirements can improve the
efficiency of concurrent test generation. however, if any two
methods of a class under test (cut) constitute a method pair,
there will be a large numbers of concurrent method pairs.
in fact, many method pairs are redundant because two meth-
ods can neither execute concurrently nor lead to concurrency
26984
2169-3536 
 2019 ieee. translations and content mining are permitted for academic research only.
personal use is also permitted, but republication/redistribution requires ieee permission.
see http://www.ieee.org/publications_standards/publications/rights/index.html for more information.
volume 7, 2019
l. bo et al.: efficient test case generation for thread-safe classes
figure 1. overview of bc-contest.
conflicts. it is both time-consuming and useless to generate
tests for these method pairs.
in this paper, we present a novel approach named
bc-contest (bug-driven and coverage-guided concurrent
test generation) to generate concurrent tests. it uses static
analysis to improve the efficiency of test generation. first,
we statically analyze the bytecode files of cuts to filter the
initial set of method pairs. in the initial set of method pairs,
each method pair consists of any two methods. then, we iter-
atively generate a concurrent test and execute it to detect
concurrency bugs. in each iteration, method pair that is most
likely to trigger bugs can be selected so as to find concurrency
bugs as soon as possible. finally, we evaluate the bug finding
capacities and efficiency of bc-contest on 20 thread-safe
classes and empirically compare it with the state-of-the-art
approaches. the results show that our approach outperforms
compared approaches.
the main contributions of this work are concluded as
follows:
• we propose a novel test case generation approach
named bc-contest for thread-safe classes. it com-
bines bug-driven grouping of method pairs and
coverage-guided generation of concurrent tests.
• we evaluate the bug finding capacities and efficiency of
bc-contest on 20 thread-safe classes, and compare it
with the state-of-the-art approaches. the results show
that our approach can improve the efficiency signifi-
cantly without impairing bug finding capacities.
the remainder of this paper is organized as follows. our
approach is described in section ii. section iii presents an
empirical study to show its validity. section iv summarizes
the related work. finally, we draw conclusions of this paper
in section v.
ii. our approach
a. overview
the overview of our approach is shown in fig. 1. it consists
of three steps: static analysis, bug-driven grouping of method
pairs and iterative generation of concurrent test cases. the
first step is static analysis. we use static analysis to identify
variable access and lock information in cut. the second step
is bug-driven grouping of method pairs. the method pairs are
divided into two groups. one is the group of method pairs
which have more possibility to expose concurrency bugs.
hence, it is given a high priority. the other is the group of the
remaining method pairs. it is given a low priority. the final
step is iterative generation of concurrent test cases, which
consists of coverage-guided generation of concurrent test
cases and concurrency bug detection. as this is a process of
iteration, we take them as a whole. concurrent test generation
first selects method pairs from the group with a high priority.
only if all the method pairs in it have been selected yet not
find concurrency bugs, method pairs from the group with a
low priority will be selected. our approach combines bug-
driven grouping of method pairs with coverage-guided gen-
eration of concurrent tests, which can improve the efficiency
of concurrency bug detection.
b. static analysis
static analysis is used to obtain the class information, includ-
ing member variable accesses, member methods, method
call relationships, lock and unlock operations. the reasons
for static analysis firstly are that: 1) our approach requires
nothing but classes under test, thus they cannot be executed in
the beginning; 2) although classes under test will be executed
with the driver of generated concurrent tests in the third
step, dynamic analysis is extremely time-consuming; 3) bug-
driven grouping of method pairs is based on the data accesses
in methods, thus it is necessary to conduct static analysis
before grouping.
as our approach is specific to java classes, our static analy-
sis is based on soot, a java bytecode analysis framework. the
source code of cut should firstly be complied into bytecode.
if the current cut extends some classes, its super classes
will also be analyzed. every field access in these classes is
instrumented and identified by soot.1
note that our approach aims to generate concurrent tests
for two publicly accessible methods, thus only public meth-
ods are instrumented and analyzed. specifically, lock and
unlock operations can be identified by entermonitorstmt()
1http://www.sable.mcgill.ca/soot.
volume 7, 2019 26985
l. bo et al.: efficient test case generation for thread-safe classes
and exitmonitorstmt(). corresponding locks can also be
obtained. synchronized methods can be identified by func-
tion issynchronized(). hence, the method pairs can be
removed directly if both are synchronized methods. in addi-
tion, if method f1 calls method f2, field access information in
f2 will be copied into f1. finally, the complete class informa-
tion is collected.
c. bug-driven grouping of method pairs
a concurrency bug occurs when two threads access a com-
mon variable concurrently with at least a write access.
like [12], our approach generates a concurrent test for
each method pair, which is constituted with two methods.
we divide the method pairs into two groups based on the
bug-driven techniques. the key insight of our grouping strat-
egy is that, it is more likely to expose concurrency bugs if
two threads access a common variable concurrently with at
least a write access, i.e., accesses to common variables are
not protected by common locks. in this case, we will assign a
high priority to the method pairs. then, the remainingmethod
pairs are given a low priority.
first, we remove the method pairs, in which both are
synchronized methods, since they cannot execute concur-
rently. next, we focus on two situations to search for
the common locks that protect the accesses of common
fields: 1) writing common fields occurs in both meth-
ods, and 2) writing common fields occurs only in one
method (all accesses to common fields are read in the other
method). we call the first and the second situations as write-
write method pair (ww) and write-read method pair (wr),
respectively.
we adopt tree structure to record the maximum protect
lock (mpl) for all accesses of each common field. for the
first situation, concurrency conflicts will not occur if all
accesses to common fields are protected by the same locks.
therefore, maximum protect lock of each common field in
each method is defined as the follows.
definition 1 [maximum protect lock for ww (mplww )]:
in each method m, given a set of all accesses to a common
field x, accmx and a set of all the lock objects lockmx ,
maximum protect lock is a subset of lockmx , in which any
of the locks can protect all accesses to the common field x.
it can be formalized as the follows:
mpl = {locki|locki ∈ lockmx ∧ ∀accx ∈ accmx ,
accx is protected by locki,
i = 1, 2, 3, . . . ; x = 1, 2, 3, . . .} (1)
for the second situation, concurrency conflicts will not
occur if only the write accesses in the write method and the
read accesses in the read method are protected by the same
locks. therefore,maximumprotect lock of the common field
in each method is defined as the follows:
definition 2 [maximum protect lock for wr (mplwr)]:
in method m1 in which all accesses to the common field are
read, given a set of all read accesses to a common field x,
figure 2. access trees of all common fields (x and y) in method
m1 and m2.
accmrx and a set of all the lock objects lockmx , maximum
protect lock is a subset of lockmx , in which any of the
locks can protect all accesses to the common field x. it can
be formalized as the follows:
mplr = {locki|locki ∈ lockmx ∧ ∀accx ∈ accmrx ,
accx is protected by locki,
i = 1, 2, 3, . . . ; x = 1, 2, 3, . . .} (2)
in methodm2, given a set of all write accesses to a common
field x, accmwx and a set of all the lock objects lockmx ,
maximum protect lock is a subset of lockmx , in which any
of the locks can protect all accesses to the common field x.
it can be formalized as the follows:
mplw = {locki|locki ∈ lockmx ∧ ∀accx ∈ accmwx ,
accx is protected by locki,
i = 1, 2, 3, . . . ; x = 1, 2, 3, . . .} (3)
for each common field, we construct their access trees
for two methods, separately. then, we traverse the nodes in
the trees top-down and calculate the mpls of two methods
(mpl1 and mpl2) according to the above definitions. if the
intersection of mpl1 and mpl2 is null, it implies that the
accesses to the common field are not protected by common
locks. thus, this method pair is assigned a high priority.
otherwise, it is assigned a low priority.
next, we give an example to illustrate mpl and our static
analysis. fig. 2 presents two access trees for all common
fields x and y in method m1 and m2, respectively. in each
access tree, the root node, represented by a square box, indi-
cates a method. the text in the box shows its method name.
the difference is that, a double bordered square box means
this is a synchronized method and the lock is this. circles
indicate the accesses (read and write accesses) to common
fields. the lock and unlock nodes are represented by the
corresponding symbols.
bothm1 andm2 contain read and write accesses to x and y.
specifically, there is a nested synchronized block in m1.
after entering m1, lock l1 is obtained. in this synchronized
26986 volume 7, 2019
l. bo et al.: efficient test case generation for thread-safe classes
figure 3. access trees of the common field x in method m1 and m2.
figure 4. access trees of the common field y in method m1 and m2.
block, field x is first read. then, lock l2 is obtained. in the
synchronized block locked by l2, the common fields x is
written and then y is read. after that, lock l2 is released
followed by reading x. finally, lock l1 is released. in method
m2, the situation is different with that inm1. first of all, object
lock this is obtained as m2 is a synchronized method. after
entering m2, the common field x is read. then, two locks
l1 and l2 are obtained and then released one by one. in the
synchronized block locked by l1, x is written. in the synchro-
nized block locked by l2, x is read followed by writing y.
after the lock l2 is released, y is read. at last, lock this is
released.
our approach constructs access trees for each common
field separately. fig. 3 and fig. 4 present the access trees for
the common field x and y, respectively. the method pair for
x belongs to the first situation. the method pair for y belongs
to the second situation. we randomly select a pair of access
trees of a certain common field. assume that the common
field x is firstly selected. thempls can be calculated by (1).
in fig. 3, the mpls of x in method m1 and m2 are {l1} and
{this}. according to (4), we can conclude that invocations
of method m1 and m2 concurrently may lead to concurrent
conflict. then, the method pair (m1,m2) is added to the group
with a high priority.
{l1} ∩ {this} = ∅ (4)
since (m1,m2) has been confirmed to be added to the group
with a high priority, the access trees of other common fields
will not be analyzed any more. however, if the common field
y is first selected, the analysis is difference. as only read
access to y occurs in method m1, themplr can be calculated
by (2). based on definition 2 and (3), we can get mplw in
method m2. thus,mplr andmplw of the common field y in
m1 and m2 are {l1, l2} and {this, l2}, respectively. according
to (5), we can find that the read accesses to y in m1 and the
write accesses to y inm2 are protected by the common lock l2.
{l1, l2} ∩ {this, l2} = {l2} (5)
however, whether a method pair should be added to the
group with a low priority does not only depend on one field.
in other words, only if all the fields are checked and the
related accesses to them are protected by the common locks,
the method pair can be added to the group with a low priority.
in this example, we have to analyze access trees of the other
common field y. as described above, invocations of method
m1 and m2 concurrently may lead to concurrent conflicts.
thus, the analysis is stopped. we can get a conclusion that
invocating m1 and m2 concurrently has a high probability to
expose concurrent conflicts. therefore, (m1, m2) is added to
the group of a high priority.
the process of bug-driven grouping of method pairs is
shown in algorithm 1. algorithm 1 takes the initial set of
method pairs initmethpairs constituted with any two meth-
ods of cut as input, and takes two grouped set of method
pairs highpriomethpairs, lowpriomethpairs as output. for
each method pair in initmethpairs, it will be removed from
initmethpairs if both of the two methods in this method
pair are synchronized methods (lines 2 and 3). otherwise,
bug-driven grouping of method pairs is conducted. first, the
common fields are computed (lines 5-7). if there are no
common fields, this method pair is given a low prior and the
next method pair is considered (lines 8 and 9). otherwise,
for each common field, two access trees are constructed to
represent all accesses of the common field in two methods.
if all accesses to the common field are read in one method,
mpls are computed with equation (2) and equation (3) (lines
19-24). otherwise, mpls are computed with equation (1)
(line 26). after computing mpls, we check the intersection
of two mpls. if the intersection is null, this method pair
is added to highpriomethpairs, which implies that it has
more possibility to detect potential concurrency bugs if these
two methods execute concurrently (lines 27 and 28). then,
other access trees in these two methods will not be analyzed
any more. but if the intersection is not null, the access trees
of the next common field should be analyzed. only if the
access trees of all common fields are checked and all the
intersections are not null, this method pair will be given a low
priority and then be added to lowpriomethpairs (line 30).
volume 7, 2019 26987
l. bo et al.: efficient test case generation for thread-safe classes
algorithm 1 bug-driven grouping of method pairs
input: initmethpairs - the initial set of method pairs.
output: highpriomethpairs - the set of method pairs with
high priority.
lowpriomethpairs- the set of method pairs with low
priority.
begin
1: for each methodpair ∈ initmethpairs do
//remove synchronized method pairs
2: if both of methods in methodpair are synchronized
methods then
3: remove methodpair from initmethpairs;
4: else
//group method pairs based on bug-driven idea
5: accefields1 = set of accessed fields in the first
method m1;
6: accefields2 = set of accessed fields in the second
method m2;
7: samfields = accefields1 ∩ accefields2;
8: if samfields = ø then
9: continue;
10: else
11: totalacctypes = set of all the accessed types of
all the same fields
in samfields;
12: if totalacctypes.size = 1 && totalacctypes.
get(0)=‘‘read’’ then
13: continue;
14: else
15: for each samfield ∈ samfields do
16: construct access trees representing all
accesses of samfield;
17: acctypes1 = set of all accessed types of
samfield in m1;
18: acctypes2 = set of all accessed types of
samfield in m2;
19: if (acctypes1.size = 1 && acctypes1.
get(0) = ‘‘read’’) then
20: compute mpl1 with equation (2);
21: compute mpl2 with equation (3);
22: else if (acctypes2.size = 1&&acctypes2.
get(0) = ‘‘read’’) then
23: compute mpl1 with equation (3);
24: compute mpl2 with equation (2);
25: else
26: compute mpl1 and mpl2 with
equation (1);
27: if mpl1∩ mpl2 = ø then
28: highpriomethpairs.
add(methodpair);
29: break;
30: lowpriomethpairs = initmethpairs.
removeall(highpriomethpairs);
31: return highpriomethpairs, lowpriomethpairs;
end
d. iterative generation of concurrent tests
after bug-driven grouping of method pairs, two sets are
obtained, i.e., highpriomethpairs and lowpriomethpairs.
figure 5. overview of iterative generation of concurrent tests.
the method pairs in highpriomethpairs are more likely to
expose concurrency bugs when two methods of each method
pair execute concurrently. therefore, we give preference to
the method pairs in highpriomethpairs to generate concur-
rent test cases and then to detect concurrency bugs.
the generation of concurrent tests is a process of iterative
learning. it is based on the coverage-guided techniques. the
key insight is to guide test generation toward not yet covered
interleavings. that can avoid repeatedly generating tests to
explore the interleavings which cannot expose concurrency
bugs.
in order to select two methods that are more likely to
expose concurrency bugs when they execute concurrently,
we designed a method pair prioritization strategy. this is
inspired by the priority mechanism in [15]. next, we present
a formal definition of several symbols:
• p is a concurrent method pair, that is, twomethods which
may execute concurrently;
• r is the number of tests that tried to cover p;
• c is the number of tests that has indeed covered p in
program execution;
• s(p) is the prioritization score of p.
then, s(p) can be computed by the following formula (6):
s(p) = max(|r − c|, 1) · r (6)
where r is initialized to 1. then, the number of r will plus one
if the corresponding method pair is selected. as every itera-
tion proceeds, r and c are updated. hence, the prioritization
scores of every method pairs are updated after every iteration.
the overview of iterative generation of concurrent tests is
presented in fig. 5. as shown in fig. 5, method pairs inhigh-
priomethpairs receive the high priority, that is, we firstly
select method pairs in highpriomethpairs. after a method
pair is selected, concurrent test cases will be generated for it.
26988 volume 7, 2019
l. bo et al.: efficient test case generation for thread-safe classes
then, each concurrent test is executed to expose concurrency
bugs based on the thread safety oracle. if concurrency bugs
are not exposed, the trace coverage information is collected
and analyzed. based on the trace coverage information, pri-
oritization scores for the method pairs are updated so as to
select the method pair with the highest priority in the next
iteration. if all the method pairs in highpriomethpairs are
selected yet no concurrency bugs are found, our approach
turns to select method pairs from lowpriomethpairs. the
procedure will be repeated until concurrency bugs in cuts
are found or timeout.
iii. experiments
in this section, we conducted some experiments to evaluate
the validity of our approach. all the experiments are con-
ducted on the same platform, i.e., a virtual machine running
the ubuntu-16.04, hosted on a dell server with 32gb of
memory and two 2.40ghz xeon x5675 cpus.
a. experimental design
our static analysis is implemented based on soot, a java
program analysis framework. in addition, we utilize the exist-
ing test generator to generate concurrent test cases. in test
execution, random scheduling of jvm scheduler is adopted to
explore the scheduling space. all the data results are averaged
over 10 times for each cut. the time-out of bug detection in
each time is one hour.
to comprehensively show the validity of bc-contest,
we compare our approach with four existing concur-
rent test generation techniques, i.e., covcon [12], con-
tege [6], nainom [7]–[9] and autocontest [11]. covcon
detects thread-safety violations via coverage-guided gen-
eration of concurrent tests. contege is a random-based
approach. it generates concurrent tests by randomly select-
ing methods to schedule under multiple concurrent threads.
nainom is a combination of narada, intruder and omen,
which are sequential test-based approaches. the sequential
tests are generated by feedback-directed random test genera-
tion (e.g., randoop [16]). autocontest is also a coverage-
based approach yet is specialized in atomicity violation
detection.
b. experimental subjects
we select 20 thread-safe classes as our experimental subjects.
table 1 presents their detailed information, i.e., class id (col-
umn 1), class name (column 2), lines of code (column 3),
number of methods (column 4), number of method pairs
(column 5) and bug type (column 6). the max size in lines
of code is 3080. the number of methods is from 8 in hashset
to 217 in xyplot.
the initial number of method pairs is calculated by (7),
f (n) = c2n + n (7)
where n indicates the number of methods. in this paper,
we calculate the combination of any two methods rather than
the permutation, because the concurrent test cases generated
table 1. experimental subjects.
table 2. the time required to find bugs with bc-contest and the existing
approaches.
for (m1, m2) and (m2, m1) are equivalent for bug detection.
moreover, (mi, mi) (i = 1, 2, 3, . . . , n) can also construct a
concurrent method pair.
c. experimental results and analysis
1) comparison with the state-of-the-art
approaches on bug finding capability
bug finding capabilities reflect that whether the approaches
can find the bugs in cuts. table 2 presents, for each class,
the class name (column 1) and the time required to find the
volume 7, 2019 26989
l. bo et al.: efficient test case generation for thread-safe classes
bugs in themwith five approaches (column 2-6). ‘‘3600’’ and
‘‘-’’ represent time-out and tool crash, respectively.
the results in table 2 show that only bc-contest and cov-
con can successfully find all concurrency bugs in 20 cuts
within one hour. contege cannot find the concurrency bugs
in synchronizedmap because of time-out. its random selec-
tion makes it consume too much time to repeatedly test
behaviors that have been exercised and miss the chance to
test behaviors that can expose concurrency bugs. nainom
cannot find the concurrency bugs in nine cuts due to time-
out. there are two reasons for this: 1) its static inference,
combination and validation operations reduce the efficiency
of finding bugs, 2) the pre-given sequential tests limit its
effectiveness of bug detection. autocontest is inferior to
other approaches in bug finding capacities since it is just
designed for detecting atomicity violations.
2) comparison with the state-of-the-art
approaches on efficiency
efficiency is represented by the time required to find the
concurrency bugs in thread-safety classes. in table 2, the sig-
nificant efficiency improvements of our approach compared
with other approaches aremarked by printing the time in bold.
from the data in table 2, we can conclude that bc-contest
can generate tests and find concurrency bugs in 257.9s on
average, which is at least 2x faster than covcon (586.14s).
autocontest occurs the situations of both time-out and the
tool crash, which implies that it is not general enough for
multiple kinds of concurrency bugs.
bc-contest combines bug-driven and coverage-guided
techniques to generate concurrent test cases for thread-safe
classes. the method pair with the highest priority is selected
in each iteration, which implies that we always try to generate
concurrent test cases to find the concurrency bugs with the
maximum possibility. thus, it can find the concurrency bugs
in all cuts efficiently. for example, for peruserpooldata-
source and sharedpooldatasource, bc-contest is 149x and
57x faster than contege.
for xyseries and stringbuffer(jdk1.6), the time con-
sumed by bc-contest is slightly more than that with cov-
con. the reason is that, the concurrency bugs are found by
the concurrent test cases generated for the method pairs in the
group of low priority. specifically, in stringbuffer, there is no
method pairs in which common variables are accessed with
at least a write access and are protected by common locks.
similar to covcon, the prioritization strategy is less success-
ful for xstream in steering testing toward higher interleaving
coverage. that is why bc-contest is slower than contege
for it.
next, we focus on using statistical tests to explore the
difference between bc-contest and covcon on efficiency
since they have the same bug finding capacities. we ran each
approach 10 times for each program. fig. 6 shows the time
distribution required to trigger concurrency bugs in 20 cuts
in 200 runs. from fig. 6 we can find the red boxes are
much shorter than the green boxes, which implies that the
figure 6. time required to trigger the concurrency bugs in 20 cuts
in 200 runs.
time distribution with bc-contest is much concentrated.
moreover, fig. 6 can clearly show that the time required to
find the concurrency bugs by bc-contest is much less than
that by covcon in total 200 runs.
in order to prove the significance of the difference between
bc-contest and covcon on efficiency, we calculated the p-
value (a number of p-value below 0.05 is considered statisti-
cally significant) using two tailed mann-whitney u test and
wilcoxon w test. the test result shows that the p-value of
two approaches is 0.00088, which is much less than 0.05.
this indicates that there is a significant difference between
bc-contest and covcon.
in addition, cohen’s d was also applied to measure the
effect size between two approaches. the calculation of
cohen’s d is presented in (8):
cohen′s d =
m1 −m2√
(σ 21 + σ
2
2 )/2
(8)
m1 and m2 represent the means of the experimental and
control groups. σ1 and σ2 represent the standard deviations
of the experimental and control groups.
table 3 presents the statistical test results of bc-contest
and covcon, including the mean values, variances, stan-
dard deviations and cohen’s d . the cohen’s d result of
bc-contest and covcon is -0.338.
to sum up, we can conclude that bc-contest signifi-
cantly performs better than the state-of-the-art covcon on
efficiency.
3) comparison on bug-driven grouping
of method pairs
both covcon and bc-contest adopt the coverage-guided
technique. covcon selects a method pair from all the method
pairs which are constituted by any two methods. unlike
covcon, bc-contest uses bug-driven grouping of method
pairs to divide the initial method pairs into two groups with
two priorities. to improve the efficiency of concurrency bug
detection, method pairs from the group with a high priority
are firstly selected. only if all the method pairs in it have been
26990 volume 7, 2019
l. bo et al.: efficient test case generation for thread-safe classes
table 3. statistical test results of bc-contest and covcon.
figure 7. number of generated concurrent test cases for 20 cuts with
bc-contest and bc-contest-ng.
selected yet not find concurrency bugs, method pairs from the
group with a low priority are selected.
to validate the effectiveness and efficiency of our bug-
driven grouping of method pairs, we compared bc-contest
with bc-contest-ng on the number of generated concur-
rent tests and the time required to find concurrency bugs.
here, bc-contest-ng means to conduct bc-contest with-
out grouping of method pairs.
the comparison results of bc-contest and bc-contest-
ng for 20 cuts are presented in fig. 7 and fig. 8.
fig. 7 shows the number of generated concurrent test
cases with bc-contest and bc-contest-ng. overall,
bc-contest can find the concurrency bugs with much less
concurrent tests than bc-contest-ng. fig. 8 shows the time
required to find the concurrency bugs in 20 cuts. the bars
in fig. 8 are basically coincided with those in fig. 7. the
more concurrent test cases it generated, the more time it
required to find the concurrency bugs. for bufferedinput-
stream (id = 5) and logger (id = 9), bc-contest can
reduced the time cost by 91.24% and 90.03%, respectively.
according to the data we collected, we know that bc-
contest reduced the number of generated concurrent test
cases and time cost by 47.94% and 61.04%, respectively. this
reduction further validates the efficiency of our approach and
the contribution of bug-driven grouping of method pairs.
contrary to the most cuts, we find that bc-contest
generates more concurrent test cases and consumes more
time than bc-contest-ng for stringbuffer (id = 13).
as we explained in the last section, the concurrency bug in
stringbuffer(jdk1.6) was found by the concurrent test gen-
erated for the method pair in lowpriomethpairs. therefore,
figure 8. time required to find concurrency bugs in 20 cuts with
bc-contest and bc-contest-ng.
figure 9. comparison results of time cost with four prioritization
strategies.
it consumed an amount of time to search for method pairs to
generate concurrent test cases and to detect concurrency bugs.
4) comparison with other prioritization strategies
on coverage-guided generation of concurrent
test cases
the goal of this study is to validate the efficiency of different
prioritization strategies onmethod pair selection. to complete
this goal, we compared our coverage-guided prioritization
strategy with that used in covcon, naïve prioritization and
random selection. naïve prioritization means to select the
method pair that has been tried the least number of times.
to avoid biasing, four prioritization strategies are applied to
the grouped method pairs.
fig. 9 shows the comparison results of time cost with four
prioritization strategies, i.e., bc-contest, covcon_g, naïve
prioritization and random selection. covcon_g means to
conduct the prioritization strategy of covcon in two grouped
method pairs.
the results in fig. 9 show that, 1) our prioritization strategy
performs much better than naïve prioritization and random
selection, 2) it is better or comparable to covcon. in addition,
we can see that, there are 18 cuts whose time cost with
bc-contest is less than that with covcon_g. this implies
volume 7, 2019 26991
l. bo et al.: efficient test case generation for thread-safe classes
figure 10. breakdown of overall execution time of bc-contest.
that our prioritization strategy has good guidance for method
pairs selection for most thread-safe classes. for example,
for xstream (id = 15), bc-contest reduced the time by
38.08% than covcon_g.
5) breakdown of overall execution time
to explore how much time bc-contest spends on static
analysis and grouping of method pairs, we recorded the
time spent in different parts of bc-contest. fig. 10 shows
the breakdown of overall execution times for 20 thread-safe
classes. as the method pairs are grouped along with static
analysis, we viewed them as a whole and computed the time.
from fig. 10, we find that most of the time is used for
test generation. this indicates that it is very important to
adopt some measures to speed up test generation, such as
prioritization strategy. in addition, although we conduct static
analysis and method pairs grouping, they occupy only a small
proportion of the overall time, i.e., 11.34% on average.
different from other classes, for bufferedinputstream
(id = 15), static analysis and method pairs grouping occupy
the most part of overall time (65%). two main reasons are for
this difference: 1) there are only nine methods in buffered-
inputstream, which is smaller than that in other classes.
what’s more, there are only six method pairs in the group
with high priority. the concurrency bug is just found when
execute the concurrent test generated for the method pair in
the group with high priority. 2) the overall execution time
for bufferedinputstream is only 2.2s, most of which is used
to write the analysis results to files.
d. threats to validity
although the experimental results show the superior effi-
ciency of our approach over the state-of-the-art approaches,
there are several threats to the validity of our experiments.
they can be summarized into two aspects.
1) internal validity
static analysis may be the threat to the internal validity.
there are many challenges in static analysis, such as alias
analysis and flow/context sensitivity. for efficiency, our
static analysis is based on the flow-insensitive and context-
insensitive points-to analysis, which may affect the precision.
to avoid false positives from static analysis, we just remove
the method pairs in which both are synchronized methods.
then only part of the remaining method pairs are firstly
selected. if the concurrency bugs are not found, the sec-
ond group will be considered. the autort proposed by
schimmel et al. [2] also used a single static analysis to iden-
tify methods that cannot be executed in parallel for improving
concurrent test generation. it reduced method pairs follow-
ing four requirements. in contrast to bc-contest, autort
only focuses on the method pairs that are relevant for data
race detection. bc-contest is more generalized, which can
detect many kinds of concurrency bugs. next, we will ref-
erence to the requirements in autort and use a more pre-
cise points-to analysis with flow-sensitivity [17] as well as
context-sensitivity [18], [19] to enhance the effectiveness of
our approach.
in addition, as our static analysis is implemented based on
soot, a java program analysis framework, it only works for
java classes. we plan to extend our static analysis to other
kinds of classes with llvm [20].
2) external validity
the scale and quality of classes under test may be the threat to
the external validity. we conduct experiments on 20 thread-
safe classes. although our results are satisfying, we can-
not ensure that our conclusions could hold for all classes.
therefore, we would search for more open source thread-safe
classes for future experiments.
iv. related work
in recent years, test case generation for concurrent programs
has drawn much attention from researchers. according to the
methodology of concurrent test generation, we classify the
existing approaches into three categories, i.e., random-based
approaches, sequential test-based approaches and coverage-
based approaches.
random-based approaches randomly select some meth-
ods of cuts and then schedule them by random combined
threads. burckhardt et al. [4] randomly selected constructors
to create shared objects and then randomly selected their
methods to be scheduled by multiple concurrent threads.
to reduce the time of exploring false thread interleaving,
nistor et al. [5] minimized concurrent degree to two threads
without sacrificing bug finding capacities and proposed bal-
lerina. in addition, to overcome the high false positives of
existing approaches, pradel and gross [6] presented con-
tege. contege generated concurrent tests based on random
selection and gave thread safety oracle to detect thread-
safe bugs. random-based approaches have the minimum
test requirements. however, they are inefficient as they may
repeatedly test the behaviors that have been exercised and
miss those that can expose bugs. our approach significantly
reduced the randomness by using bug-driven grouping of
26992 volume 7, 2019
l. bo et al.: efficient test case generation for thread-safe classes
method pairs and coverage-guided generation of concurrent
tests. both techniques can steer automatic test generation
toward tests that are likely to trigger concurrency bugs and to
cover not-yet-covered interleavings. therefore, our approach
is efficient in detecting concurrency bugs.
to alleviate the inefficient problem from random selection,
ma et al. [21] focused on generating a series of concurrent
test cases in an adaptive manner based on the idea of diver-
sity [22], [23]. first, two diversity metrics were presented
from a static metric and a dynamic perspective, respectively.
then, three adaptive test generation approaches for c/c++
concurrent data structures were implemented to expose more
interleaving instances with less computation time and fewer
tests. but one limitation is that they payed less attention to its
test oracle problem. our approach checks whether executing
a concurrent test can expose a concurrency bug based on the
thread safety oracle [6]. it reports concurrency bugs if the
exception occurs only in a concurrent execution but not in
any of linearization of methods.
sequential test-based approaches analyze the execution
traces of the sequential tests, identify concurrency bugs
that may occur when combining multiple sequential tests
into concurrent tests and finally synthesize such tests.
based on this idea, samak and ramanathan [7], [8] and
samak et al. [9], [24] proposed a series of concurrent test
generation approaches to detect different kinds of concur-
rency bugs. for example, omen [7] and omen+ [25] were
designed to detect deadlocks. narada [9] and intruder [8]
were developed to detect data races and atomicity violations,
respectively. minion [24] was created to detect assertion vio-
lations. sequential test-based approaches do not generate the
redundant concurrent tests that are irrelevant to the consid-
ered type of concurrency bugs. however, the effectiveness of
sequential test-based approaches depends on the pre-given
suite of sequential tests. moreover, this kind of approach
may produce an expensive computing cost. in contrast, our
approach does not need any extra tests and generates concur-
rent tests for any two feasible methods in cuts. therefore,
it is both conceptually and computationally simple, yet effec-
tive in finding concurrency bugs.
coverage-based approaches compute a set of coverage
requirements and automatically generate tests to coverage as
many requirements as possible. steenbuck and fraser [10]
defined parameterized coverage criterion, estimated all the
feasible coverage requirements and guided test generation
to cover these requirements. however, for concurrent pro-
grams, it is impractical to statically collect the whole cover-
age requirements. terragni and cheung [11] computed cov-
erage requirements dynamically in the process of exploring
method invocations to drive concurrent test generation. they
implemented autocontest, which significantly improved
the performance of test generation. however, it can only
detect atomicity violations. recently, choudhary et al. [12]
employed concurrent method pairs to be the approximate
interleaving coverage metric. the metric is both efficient and
practice to use. bianchi et al. [26] exploited a set of pruning
strategies to steer the test code generation towards tests that
are likely to reproduce failures. although our approach also
adopts concurrent method pairs as the coverage metric in the
process of concurrent test generation, there are two differ-
ences. first, our approach leverages bug-driven techniques
to divide the feasible method pairs into two groups. one
group is given a high priority, and the other group is given
a low priority. method pairs in the high priority group are
first selected for generating concurrent tests. second, a new
method pairs prioritization strategy is designed for selecting
a method pair in each iteration.
in addition, there is a large body of research involved in
exploring the thread interleaving space to find concurrency
bugs. commonly, they are based on a certain interleaving
coverage criterion [27]–[30]. lu et al. [28] summarized a
concurrent program interleaving coverage criteria hierarchy,
in which all the criteria are designed based on different
concurrency fault models. hong et al. [29] presented a novel
thread-scheduling technique in terms of synchronization-pair
coverage criterion for achieving high test coverage. later on,
they conducted a comprehensive empirical investigation of
the concurrency coverage metrics effective for testing [30].
from another perspective, yu et al. [31] defined a coverage
metric based on a set of interleaving idioms. an interleav-
ing idiom represented a pattern of inter-thread dependencies
and indicated a happens-before relation between conflicting
memory accesses by different threads.
different from all the above coverage criteria, our approach
generates unit test cases for thread-safe classes based on an
approximate interleaving coverage metric, i.e., concurrent
method pairs. this coverage criterion is first proposed by
deng et al. [13] for reducing the dynamic bug-detection cost
for predefined inputs. in this paper, we use it to reduce the
computation and time cost of concurrent test generation.
v. conclusion
in this paper, we present an efficient test generation approach
for thread-safe classes. we first adopt static analysis to
remove the method pairs that cannot execute concurrently.
then, we group the remaining method pairs based on the
bug-driven techniques. finally, we iteratively generate con-
current test cases with the coverage-guided techniques and
execute them with thread safety oracle to find the concur-
rency bugs. our experimental results show that, bc-contest
can obtain a significant improvement on efficiency without
impairing bug finding capacities. in the future, we will com-
bine active testing [32]–[35] to further improve the efficiency
of concurrency bug detection. in addition, we plan to extend
the proposed approach to the massage-passing parallel pro-
grams [36], [37] to improve its generalization.
acknowledgment
the authors would like to thank editors and anonymous
reviewers for their valuable comments and useful sugges-
tions. they would also like to thank all the individuals who
volume 7, 2019 26993
l. bo et al.: efficient test case generation for thread-safe classes
participated and contributed to improve the quality and read-
ability of this paper.
references
[1] v. terragni andm. pezzè, ‘‘effectiveness and challenges in generating con-
current tests for thread-safe classes,’’ in proc. ase, montpellier, france,
sep. 2018, pp. 64–75.
[2] j. schimmel, k. molitorisz, a. jannesari, and w. f. tichy, ‘‘automatic
generation of parallel unit tests,’’ in proc. ast, san francisco, ca, usa,
2013, pp. 40–46.
[3] a. jannesari and f.wolf, ‘‘automatic generation of unit tests for correlated
variables in parallel programs,’’ int. j. parallel program., vol. 44, no. 3,
pp. 644–662, mar. 2015.
[4] s. burckhardt, c. dern, m. musuvathi, and r. tan, ‘‘line-up: a com-
plete and automatic linearizability checker,’’ in proc. pldi, toronto, on,
canada, 2010, pp. 330–340.
[5] a. nistor, q. z. luo, m. pradel, t. r. gross, and d. marinov,
‘‘ballerina: automatic generation and clustering of efficient random unit
tests for multithreaded code,’’ in proc. icse, zurich, switzerland, 2012,
pp. 727–737.
[6] m. pradel and t. r. gross, ‘‘fully automatic and precise detection
of thread safety violations,’’ in proc. pldi, beijing, china, 2012,
pp. 521–530.
[7] m. samak and m. k. ramanathan, ‘‘multithreaded test synthesis for
deadlock detection,’’ in proc. oopsla, portland, or, usa, 2014,
pp. 473–489.
[8] m. samak and m. k. ramanathan, ‘‘synthesizing tests for detecting atom-
icity violations,’’ in proc. fse, bergamo, italy, 2015, pp. 131–142.
[9] m. samak, m. k. ramanathan, and s. jagannathan, ‘‘synthesizing racy
tests,’’ in proc. pldi, portland, or, usa, 2015, pp. 175–185.
[10] s. steenbuck and g. fraser, ‘‘generating unit tests for concurrent classes,’’
in proc. icst, luxembourg, 2013, pp. 144–153.
[11] v. terragni and s.-c. cheung, ‘‘coverage-driven test code genera-
tion for concurrent classes,’’ in proc. icse, austin, tx, usa, 2016,
pp. 1121–1132.
[12] a. choudhary, s. lu, and m. pradel, ‘‘efficient detection of thread safety
violations via coverage-guided generation of concurrent tests,’’ in proc.
icse, buenos aires, argentina, 2017, pp. 266–277.
[13] d. deng, w. zhang, and s. lu, ‘‘efficient concurrency-bug detec-
tion across inputs,’’ in proc. oopsla, indianapolis, in, usa, 2013,
pp. 785–802.
[14] s. lu, s. park, e. seo, and y. y. zhou, ‘‘learning from mistakes:
a comprehensive study on real world concurrency bug characteristics,’’
in proc. asplos, mar. 2008, pp. 329–339.
[15] l. qi, w. dou, w. wang, g. li, h. yu, and s. wan, ‘‘dynamic mobile
crowdsourcing selection for electricity load forecasting,’’ ieee access,
vol. 6, pp. 46926–46937, 2018.
[16] c. pacheco, s. k. lahiri, m. d. ernst, and t. ball, ‘‘feedback-directed
random test generation,’’ in proc. icse, minneapolis, mn, usa, 2007,
pp. 75–84.
[17] b. hardekopf and c. lin, ‘‘flow-sensitive pointer analysis for millions of
lines of code,’’ in proc. cgo, chamonix, france, 2011, pp. 289–298.
[18] y. smaragdakis, g. kastrinis, and g. balatsouras, ‘‘introspective analysis:
context-sensitivity, across the board,’’ in proc. pldi, edinburgh, u.k.,
2014, pp. 485–495.
[19] c. vassallo et al., ‘‘context is king: the developer perspective on the
usage of static analysis tools,’’ in proc. saner, beijing, china, mar. 2018,
pp. 38–49.
[20] the llvm compiler infrastructure. accessed: dec. 21, 2018. [online].
available: http://llvm.org/
[21] l. ma, p. wu, and t. y. chen, ‘‘diversity driven adaptive test generation
for concurrent data structures,’’ inf. softw. technol., vol. 103, pp. 162–173,
jul. 2018.
[22] t. y. chen, f.-c. kuo, d. towey, and z. zhou, ‘‘a revisit of three studies
related to random testing,’’ sci. china inf. sci., vol. 58, no. 5, pp. 1–9,
may 2015.
[23] t. y. chen, f.-c. kuo, r. g. merkel, and t. h. tse, ‘‘adaptive random
testing: the art of test case diversity,’’ j. syst. softw., vol. 83, no. 1,
pp. 60–66, mar. 2009.
[24] m. samak, o. tripp, andm. k. ramanathan, ‘‘directed synthesis of failing
concurrent executions,’’ in proc. oopsla, amsterdam, the netherlands,
2016, pp. 430–446.
[25] m. samak and m. k. ramanathan, ‘‘omen+: a precise dynamic deadlock
detector for multithreaded java libraries,’’ in proc. fse, hong kong, 2014,
pp. 735–738.
[26] f. a. bianchi, m. pezzè, and v. terragni, ‘‘reproducing concurrency
failures from crash stacks,’’ in proc. esec/fse, paderborn, germany,
2017, pp. 705–716.
[27] a. bron, e. farchi, y. magid, y. nir, and s. ur, ‘‘applications of
synchronization coverage,’’ in proc. ppopp, chicago, il, usa, 2005,
pp. 206–212.
[28] s. lu, w. jiang, and y. zhou, ‘‘a study of interleaving coverage criteria,’’
in proc. fse, dubrovnik, croatia, 2007, pp. 533–536.
[29] s. hong, j. ahn, s. park, m. kim, and m. j. harrold, ‘‘testing concurrent
programs to achieve high synchronization coverage,’’ in proc. issta,
minneapolis, mn, usa, 2012, pp. 210–220.
[30] s. hong, m. staats, j. ahn, m. kim, and g. rothermel, ‘‘are concurrency
coverage metrics effective for testing: a comprehensive empirical investi-
gation,’’ softw. test., verification reliabil., vol. 35, pp. 334–370, jun. 2014.
[31] j. yu, s. narayanasamy, c. pereira, and g. pokam, ‘‘maple:
a coverage-driven testing tool for multithreaded programs,’’ in proc.
ooplsa, tucson, az, usa, 2012, pp. 485–502.
[32] p. joshi, m. naik, c.-s. park, and k. sen, ‘‘calfuzzer: an extensible active
testing framework for concurrent programs,’’ in proc. cav, grenoble,
france, 2009, pp. 675–681.
[33] c. s. park and k. sen, ‘‘randomized active atomicity violation detec-
tion in concurrent programs,’’ in proc. fse, atlanta, ga, usa, 2008,
pp. 135–145.
[34] k. sen, ‘‘race directed random testing of concurrent programs,’’ in proc.
pldi, tucson, az, usa, 2008, pp. 11–21.
[35] h. yue, p. wu, t. y. chen, and y. lv, ‘‘input-driven active testing of
multi-threaded programs,’’ in proc. apsec, new delhi, india, 2015,
pp. 246–253.
[36] t. tian and d. gong, ‘‘test data generation for path coverage of
message-passing parallel programs based on co-evolutionary genetic algo-
rithms,’’ auto. softw. eng., vol. 23, no. 3, pp. 469–500, nov. 2014.
[37] d. gong, c. zhang, t. tian, and z. li, ‘‘reducing scheduling sequences
of message-passing parallel programs,’’ inf. softw. technol., vol. 80,
pp. 217–230, sep. 2016.
lili bo is currently pursuing the ph.d. degree
with the school of computer science and technol-
ogy, china university of mining and technology.
her research interests include software analysis
and testing.
shujuan jiang received the ph.d. degree from
southeast university, in 2006. she is currently a
professor and a ph.d. supervisor with the school
of computer science and technology, china uni-
versity of mining and technology. her research
interests include compilation techniques and soft-
ware engineering.
26994 volume 7, 2019
l. bo et al.: efficient test case generation for thread-safe classes
junyan qian is currently a professor and a
ph.d. supervisor with the guangxi key lab-
oratory of trusted software, guilin university
of electronic technology. his research interests
include software engineering, model checking,
and program verification.
rongcun wang received the ph.d. degree
from the huazhong university of science and
technology, in 2015. he is currently an assistant
professor with the school of computer science
and technology, china university of mining and
technology. his research interests include soft-
ware testing, software maintenance, and machine
learning.
xingya wang received the ph.d. degree from
the china university of mining and technol-
ogy, in 2017. he is currently holding a postdoc-
toral position with the state key laboratory for
novel software technology, nanjing university.
his research interests include software testing and
program debugging.
volume 7, 2019 26995
